{"version":3,"file":"static/js/1105.9fb08921.chunk.js","mappings":"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","sources":["../node_modules/@tsparticles/updater-out-modes/browser/OutOutMode.js"],"sourcesContent":["import { Vector, calculateBounds, getDistances, getRandom, isPointInside, randomInRange, } from \"@tsparticles/engine\";\nconst minVelocity = 0, minDistance = 0;\nexport class OutOutMode {\n    constructor(container) {\n        this.container = container;\n        this.modes = [\"out\"];\n    }\n    async update(particle, direction, delta, outMode) {\n        if (!this.modes.includes(outMode)) {\n            return;\n        }\n        const container = this.container;\n        switch (particle.outType) {\n            case \"inside\": {\n                const { x: vx, y: vy } = particle.velocity;\n                const circVec = Vector.origin;\n                circVec.length = particle.moveCenter.radius;\n                circVec.angle = particle.velocity.angle + Math.PI;\n                circVec.addTo(Vector.create(particle.moveCenter));\n                const { dx, dy } = getDistances(particle.position, circVec);\n                if ((vx <= minVelocity && dx >= minDistance) ||\n                    (vy <= minVelocity && dy >= minDistance) ||\n                    (vx >= minVelocity && dx <= minDistance) ||\n                    (vy >= minVelocity && dy <= minDistance)) {\n                    return;\n                }\n                particle.position.x = Math.floor(randomInRange({\n                    min: 0,\n                    max: container.canvas.size.width,\n                }));\n                particle.position.y = Math.floor(randomInRange({\n                    min: 0,\n                    max: container.canvas.size.height,\n                }));\n                const { dx: newDx, dy: newDy } = getDistances(particle.position, particle.moveCenter);\n                particle.direction = Math.atan2(-newDy, -newDx);\n                particle.velocity.angle = particle.direction;\n                break;\n            }\n            default: {\n                if (isPointInside(particle.position, container.canvas.size, Vector.origin, particle.getRadius(), direction)) {\n                    return;\n                }\n                switch (particle.outType) {\n                    case \"outside\": {\n                        particle.position.x =\n                            Math.floor(randomInRange({\n                                min: -particle.moveCenter.radius,\n                                max: particle.moveCenter.radius,\n                            })) + particle.moveCenter.x;\n                        particle.position.y =\n                            Math.floor(randomInRange({\n                                min: -particle.moveCenter.radius,\n                                max: particle.moveCenter.radius,\n                            })) + particle.moveCenter.y;\n                        const { dx, dy } = getDistances(particle.position, particle.moveCenter);\n                        if (particle.moveCenter.radius) {\n                            particle.direction = Math.atan2(dy, dx);\n                            particle.velocity.angle = particle.direction;\n                        }\n                        break;\n                    }\n                    case \"normal\": {\n                        const warp = particle.options.move.warp, canvasSize = container.canvas.size, newPos = {\n                            bottom: canvasSize.height + particle.getRadius() + particle.offset.y,\n                            left: -particle.getRadius() - particle.offset.x,\n                            right: canvasSize.width + particle.getRadius() + particle.offset.x,\n                            top: -particle.getRadius() - particle.offset.y,\n                        }, sizeValue = particle.getRadius(), nextBounds = calculateBounds(particle.position, sizeValue);\n                        if (direction === \"right\" &&\n                            nextBounds.left > canvasSize.width + particle.offset.x) {\n                            particle.position.x = newPos.left;\n                            particle.initialPosition.x = particle.position.x;\n                            if (!warp) {\n                                particle.position.y = getRandom() * canvasSize.height;\n                                particle.initialPosition.y = particle.position.y;\n                            }\n                        }\n                        else if (direction === \"left\" && nextBounds.right < -particle.offset.x) {\n                            particle.position.x = newPos.right;\n                            particle.initialPosition.x = particle.position.x;\n                            if (!warp) {\n                                particle.position.y = getRandom() * canvasSize.height;\n                                particle.initialPosition.y = particle.position.y;\n                            }\n                        }\n                        if (direction === \"bottom\" &&\n                            nextBounds.top > canvasSize.height + particle.offset.y) {\n                            if (!warp) {\n                                particle.position.x = getRandom() * canvasSize.width;\n                                particle.initialPosition.x = particle.position.x;\n                            }\n                            particle.position.y = newPos.top;\n                            particle.initialPosition.y = particle.position.y;\n                        }\n                        else if (direction === \"top\" && nextBounds.bottom < -particle.offset.y) {\n                            if (!warp) {\n                                particle.position.x = getRandom() * canvasSize.width;\n                                particle.initialPosition.x = particle.position.x;\n                            }\n                            particle.position.y = newPos.bottom;\n                            particle.initialPosition.y = particle.position.y;\n                        }\n                        break;\n                    }\n                }\n                break;\n            }\n        }\n        await Promise.resolve();\n    }\n}\n"],"names":["OutOutMode","constructor","container","this","modes","update","particle","direction","delta","outMode","includes","outType","x","vx","y","vy","velocity","circVec","Vector","origin","length","moveCenter","radius","angle","Math","PI","addTo","create","dx","dy","getDistances","position","floor","randomInRange","min","max","canvas","size","width","height","newDx","newDy","atan2","isPointInside","getRadius","warp","options","move","canvasSize","newPos","bottom","offset","left","right","top","sizeValue","nextBounds","calculateBounds","initialPosition","getRandom","Promise","resolve"],"sourceRoot":""}