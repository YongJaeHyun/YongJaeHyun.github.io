{"version":3,"file":"static/js/8916.041490ab.chunk.js","mappings":"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","sources":["../node_modules/@tsparticles/plugin-polygon-mask/browser/PolygonMaskInstance.js"],"sourcesContent":["import { deepExtend, errorPrefix, getDistance, getDistances, getRandom, isArray, isString, itemFromArray, percentDenominator, } from \"@tsparticles/engine\";\nconst noPolygonDataLoaded = `${errorPrefix} No polygon data loaded.`, noPolygonFound = `${errorPrefix} No polygon found, you need to specify SVG url in config.`, origin = {\n    x: 0,\n    y: 0,\n}, half = 0.5, double = 2;\nexport class PolygonMaskInstance {\n    constructor(container, engine) {\n        this._checkInsidePolygon = (position) => {\n            const container = this._container, options = container.actualOptions.polygon;\n            if (!options?.enable || options.type === \"none\" || options.type === \"inline\") {\n                return true;\n            }\n            if (!this.raw) {\n                throw new Error(noPolygonFound);\n            }\n            const canvasSize = container.canvas.size, x = position?.x ?? getRandom() * canvasSize.width, y = position?.y ?? getRandom() * canvasSize.height, indexOffset = 1;\n            let inside = false;\n            for (let i = 0, j = this.raw.length - indexOffset; i < this.raw.length; j = i++) {\n                const pi = this.raw[i], pj = this.raw[j], intersect = pi.y > y !== pj.y > y && x < ((pj.x - pi.x) * (y - pi.y)) / (pj.y - pi.y) + pi.x;\n                if (intersect) {\n                    inside = !inside;\n                }\n            }\n            if (options.type === \"inside\") {\n                return inside;\n            }\n            else {\n                return options.type === \"outside\" ? !inside : false;\n            }\n        };\n        this._createPath2D = () => {\n            const container = this._container, options = container.actualOptions.polygon;\n            if (!options || !this.paths?.length) {\n                return;\n            }\n            for (const path of this.paths) {\n                const pathData = path.element?.getAttribute(\"d\");\n                if (pathData) {\n                    const path2d = new Path2D(pathData), matrix = document.createElementNS(\"http://www.w3.org/2000/svg\", \"svg\").createSVGMatrix(), finalPath = new Path2D(), transform = matrix.scale(this._scale);\n                    if (finalPath.addPath) {\n                        finalPath.addPath(path2d, transform);\n                        path.path2d = finalPath;\n                    }\n                    else {\n                        delete path.path2d;\n                    }\n                }\n                else {\n                    delete path.path2d;\n                }\n                if (path.path2d ?? !this.raw) {\n                    continue;\n                }\n                path.path2d = new Path2D();\n                const firstIndex = 0, firstPoint = this.raw[firstIndex];\n                path.path2d.moveTo(firstPoint.x, firstPoint.y);\n                this.raw.forEach((pos, i) => {\n                    if (i > firstIndex) {\n                        path.path2d?.lineTo(pos.x, pos.y);\n                    }\n                });\n                path.path2d.closePath();\n            }\n        };\n        this._downloadSvgPath = async (svgUrl, force) => {\n            const options = this._container.actualOptions.polygon;\n            if (!options) {\n                return;\n            }\n            const url = svgUrl ?? options.url, forceDownload = force ?? false;\n            if (!url || (this.paths !== undefined && !forceDownload)) {\n                return this.raw;\n            }\n            const req = await fetch(url);\n            if (!req.ok) {\n                throw new Error(`${errorPrefix} occurred during polygon mask download`);\n            }\n            return await this._parseSvgPath(await req.text(), force);\n        };\n        this._drawPoints = () => {\n            if (!this.raw) {\n                return;\n            }\n            for (const item of this.raw) {\n                void this._container.particles.addParticle({\n                    x: item.x,\n                    y: item.y,\n                });\n            }\n        };\n        this._getEquidistantPointByIndex = (index) => {\n            const container = this._container, options = container.actualOptions, polygonMaskOptions = options.polygon;\n            if (!polygonMaskOptions) {\n                return;\n            }\n            if (!this.raw?.length || !this.paths?.length) {\n                throw new Error(noPolygonDataLoaded);\n            }\n            let offset = 0, point;\n            const baseAccumulator = 0, totalLength = this.paths.reduce((tot, path) => tot + path.length, baseAccumulator), distance = totalLength / options.particles.number.value;\n            for (const path of this.paths) {\n                const pathDistance = distance * index - offset;\n                if (pathDistance <= path.length) {\n                    point = path.element.getPointAtLength(pathDistance);\n                    break;\n                }\n                else {\n                    offset += path.length;\n                }\n            }\n            const scale = this._scale;\n            return {\n                x: (point?.x ?? origin.x) * scale + (this.offset?.x ?? origin.x),\n                y: (point?.y ?? origin.y) * scale + (this.offset?.y ?? origin.y),\n            };\n        };\n        this._getPointByIndex = (index) => {\n            if (!this.raw?.length) {\n                throw new Error(noPolygonDataLoaded);\n            }\n            const coords = this.raw[index % this.raw.length];\n            return {\n                x: coords.x,\n                y: coords.y,\n            };\n        };\n        this._getRandomPoint = () => {\n            if (!this.raw?.length) {\n                throw new Error(noPolygonDataLoaded);\n            }\n            const coords = itemFromArray(this.raw);\n            return {\n                x: coords.x,\n                y: coords.y,\n            };\n        };\n        this._getRandomPointByLength = () => {\n            const container = this._container, options = container.actualOptions.polygon;\n            if (!options) {\n                return;\n            }\n            if (!this.raw?.length || !this.paths?.length) {\n                throw new Error(noPolygonDataLoaded);\n            }\n            const path = itemFromArray(this.paths), offset = 1, distance = Math.floor(getRandom() * path.length) + offset, point = path.element.getPointAtLength(distance), scale = this._scale;\n            return {\n                x: point.x * scale + (this.offset?.x ?? origin.x),\n                y: point.y * scale + (this.offset?.y ?? origin.y),\n            };\n        };\n        this._initRawData = async (force) => {\n            const options = this._container.actualOptions.polygon;\n            if (!options) {\n                return;\n            }\n            if (options.url) {\n                this.raw = await this._downloadSvgPath(options.url, force);\n            }\n            else if (options.data) {\n                const data = options.data;\n                let svg;\n                if (isString(data)) {\n                    svg = data;\n                }\n                else {\n                    const getPath = (p) => `<path d=\"${p}\" />`, path = isArray(data.path) ? data.path.map(getPath).join(\"\") : getPath(data.path);\n                    const namespaces = 'xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\"';\n                    svg = `<svg ${namespaces} width=\"${data.size.width}\" height=\"${data.size.height}\">${path}</svg>`;\n                }\n                this.raw = await this._parseSvgPath(svg, force);\n            }\n            this._createPath2D();\n            this._engine.dispatchEvent(\"polygonMaskLoaded\", {\n                container: this._container,\n            });\n        };\n        this._parseSvgPath = async (xml, force) => {\n            const forceDownload = force ?? false;\n            if (this.paths !== undefined && !forceDownload) {\n                return this.raw;\n            }\n            const container = this._container, options = container.actualOptions.polygon;\n            if (!options) {\n                return;\n            }\n            const parser = new DOMParser(), doc = parser.parseFromString(xml, \"image/svg+xml\"), firstIndex = 0, svg = doc.getElementsByTagName(\"svg\")[firstIndex];\n            let svgPaths = svg.getElementsByTagName(\"path\");\n            if (!svgPaths.length) {\n                svgPaths = doc.getElementsByTagName(\"path\");\n            }\n            this.paths = [];\n            for (let i = 0; i < svgPaths.length; i++) {\n                const path = svgPaths.item(i);\n                if (path) {\n                    this.paths.push({\n                        element: path,\n                        length: path.getTotalLength(),\n                    });\n                }\n            }\n            const scale = this._scale;\n            this.dimension.width = parseFloat(svg.getAttribute(\"width\") ?? \"0\") * scale;\n            this.dimension.height = parseFloat(svg.getAttribute(\"height\") ?? \"0\") * scale;\n            const position = options.position ?? {\n                x: 50,\n                y: 50,\n            }, canvasSize = container.canvas.size;\n            this.offset = {\n                x: (canvasSize.width * position.x) / percentDenominator - this.dimension.width * half,\n                y: (canvasSize.height * position.y) / percentDenominator - this.dimension.height * half,\n            };\n            const { parsePaths } = await import(\"./utils.js\");\n            return parsePaths(this.paths, scale, this.offset);\n        };\n        this._polygonBounce = async (particle, delta, direction) => {\n            const options = this._container.actualOptions.polygon;\n            if (!this.raw || !options?.enable || direction !== \"top\") {\n                return false;\n            }\n            if (options.type === \"inside\" || options.type === \"outside\") {\n                let closest, dx, dy;\n                const pos = particle.getPosition(), radius = particle.getRadius(), offset = 1;\n                for (let i = 0, j = this.raw.length - offset; i < this.raw.length; j = i++) {\n                    const pi = this.raw[i], pj = this.raw[j], { calcClosestPointOnSegment } = await import(\"./utils.js\");\n                    closest = calcClosestPointOnSegment(pi, pj, pos);\n                    const dist = getDistances(pos, closest);\n                    [dx, dy] = [dist.dx, dist.dy];\n                    if (dist.distance < radius) {\n                        const { segmentBounce } = await import(\"./utils.js\");\n                        segmentBounce(pi, pj, particle.velocity);\n                        return true;\n                    }\n                }\n                if (closest && dx !== undefined && dy !== undefined && !this._checkInsidePolygon(pos)) {\n                    const factor = { x: 1, y: 1 }, diameter = radius * double, inverse = -1;\n                    if (pos.x >= closest.x) {\n                        factor.x = -1;\n                    }\n                    if (pos.y >= closest.y) {\n                        factor.y = -1;\n                    }\n                    particle.position.x = closest.x + diameter * factor.x;\n                    particle.position.y = closest.y + diameter * factor.y;\n                    particle.velocity.mult(inverse);\n                    return true;\n                }\n            }\n            else if (options.type === \"inline\" && particle.initialPosition) {\n                const dist = getDistance(particle.initialPosition, particle.getPosition()), { velocity } = particle;\n                if (dist > this._moveRadius) {\n                    velocity.x = velocity.y * half - velocity.x;\n                    velocity.y = velocity.x * half - velocity.y;\n                    return true;\n                }\n            }\n            return false;\n        };\n        this._randomPoint = () => {\n            const container = this._container, options = container.actualOptions.polygon;\n            if (!options) {\n                return;\n            }\n            let position;\n            if (options.type === \"inline\") {\n                switch (options.inline.arrangement) {\n                    case \"random-point\":\n                        position = this._getRandomPoint();\n                        break;\n                    case \"random-length\":\n                        position = this._getRandomPointByLength();\n                        break;\n                    case \"equidistant\":\n                        position = this._getEquidistantPointByIndex(container.particles.count);\n                        break;\n                    case \"one-per-point\":\n                    case \"per-point\":\n                    default:\n                        position = this._getPointByIndex(container.particles.count);\n                }\n            }\n            else {\n                const canvasSize = container.canvas.size;\n                position = {\n                    x: getRandom() * canvasSize.width,\n                    y: getRandom() * canvasSize.height,\n                };\n            }\n            if (this._checkInsidePolygon(position)) {\n                return position;\n            }\n            else {\n                return this._randomPoint();\n            }\n        };\n        this._container = container;\n        this._engine = engine;\n        this.dimension = {\n            height: 0,\n            width: 0,\n        };\n        this._moveRadius = 0;\n        this._scale = 1;\n    }\n    clickPositionValid(position) {\n        const options = this._container.actualOptions.polygon;\n        return (!!options?.enable &&\n            options.type !== \"none\" &&\n            options.type !== \"inline\" &&\n            this._checkInsidePolygon(position));\n    }\n    async draw(context) {\n        if (!this.paths?.length) {\n            return;\n        }\n        const options = this._container.actualOptions.polygon;\n        if (!options?.enable) {\n            return;\n        }\n        const polygonDraw = options.draw;\n        if (!polygonDraw.enable) {\n            return;\n        }\n        const rawData = this.raw;\n        for (const path of this.paths) {\n            const path2d = path.path2d;\n            if (!context) {\n                continue;\n            }\n            if (path2d && this.offset) {\n                const { drawPolygonMaskPath } = await import(\"./utils.js\");\n                drawPolygonMaskPath(context, path2d, polygonDraw.stroke, this.offset);\n            }\n            else if (rawData) {\n                const { drawPolygonMask } = await import(\"./utils.js\");\n                drawPolygonMask(context, rawData, polygonDraw.stroke);\n            }\n        }\n    }\n    async init() {\n        const container = this._container, polygonMaskOptions = container.actualOptions.polygon, pxRatio = container.retina.pixelRatio;\n        if (!polygonMaskOptions) {\n            return;\n        }\n        this._moveRadius = polygonMaskOptions.move.radius * pxRatio;\n        this._scale = polygonMaskOptions.scale * pxRatio;\n        if (polygonMaskOptions.enable) {\n            await this._initRawData();\n        }\n    }\n    async particleBounce(particle, delta, direction) {\n        return await this._polygonBounce(particle, delta, direction);\n    }\n    particlePosition(position) {\n        const options = this._container.actualOptions.polygon, defaultLength = 0;\n        if (!(options?.enable && (this.raw?.length ?? defaultLength) > defaultLength)) {\n            return;\n        }\n        return deepExtend({}, position ? position : this._randomPoint());\n    }\n    particlesInitialization() {\n        const options = this._container.actualOptions.polygon;\n        if (options?.enable &&\n            options.type === \"inline\" &&\n            (options.inline.arrangement === \"one-per-point\" ||\n                options.inline.arrangement === \"per-point\")) {\n            this._drawPoints();\n            return true;\n        }\n        return false;\n    }\n    resize() {\n        const container = this._container, options = container.actualOptions.polygon;\n        if (!(options?.enable && options.type !== \"none\")) {\n            return;\n        }\n        if (this.redrawTimeout) {\n            clearTimeout(this.redrawTimeout);\n        }\n        const timeout = 250;\n        this.redrawTimeout = window.setTimeout(() => {\n            void (async () => {\n                await this._initRawData(true);\n                await container.particles.redraw();\n            })();\n        }, timeout);\n    }\n    stop() {\n        delete this.raw;\n        delete this.paths;\n    }\n}\n"],"names":["noPolygonDataLoaded","concat","errorPrefix","noPolygonFound","origin","half","PolygonMaskInstance","constructor","container","engine","this","_checkInsidePolygon","position","_position$x","_position$y","_container","options","actualOptions","polygon","enable","type","raw","Error","canvasSize","canvas","size","x","getRandom","width","y","height","inside","i","j","length","pi","pj","_createPath2D","_this$paths","paths","path","_path$element","_path$path2d","pathData","element","getAttribute","path2d","Path2D","matrix","document","createElementNS","createSVGMatrix","finalPath","transform","scale","_scale","addPath","firstIndex","firstPoint","moveTo","forEach","pos","_path$path2d2","lineTo","closePath","_downloadSvgPath","async","svgUrl","force","url","forceDownload","undefined","req","fetch","ok","_parseSvgPath","text","_drawPoints","item","particles","addParticle","_getEquidistantPointByIndex","index","_this$raw","_this$paths2","_point$x","_point","_this$offset$x","_this$offset","_point$y","_point2","_this$offset$y","_this$offset2","point","offset","distance","reduce","tot","number","value","pathDistance","getPointAtLength","_getPointByIndex","_this$raw2","coords","_getRandomPoint","_this$raw3","itemFromArray","_getRandomPointByLength","_this$raw4","_this$paths3","_this$offset$x2","_this$offset3","_this$offset$y2","_this$offset4","Math","floor","_initRawData","data","svg","isString","getPath","p","isArray","map","join","_engine","dispatchEvent","xml","_svg$getAttribute","_svg$getAttribute2","_options$position","doc","DOMParser","parseFromString","getElementsByTagName","svgPaths","push","getTotalLength","dimension","parseFloat","percentDenominator","parsePaths","_polygonBounce","particle","delta","direction","closest","dx","dy","getPosition","radius","getRadius","calcClosestPointOnSegment","dist","getDistances","segmentBounce","velocity","factor","diameter","inverse","mult","initialPosition","getDistance","_moveRadius","_randomPoint","inline","arrangement","count","clickPositionValid","draw","context","_this$paths4","polygonDraw","rawData","drawPolygonMaskPath","stroke","drawPolygonMask","init","polygonMaskOptions","pxRatio","retina","pixelRatio","move","particleBounce","particlePosition","_this$raw$length","_this$raw5","deepExtend","particlesInitialization","resize","redrawTimeout","clearTimeout","window","setTimeout","redraw","stop"],"sourceRoot":""}