{"version":3,"file":"static/js/5888.ffd49891.chunk.js","mappings":"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","sources":["../node_modules/@tsparticles/plugin-emitters-shape-path/browser/utils.js","../node_modules/@tsparticles/plugin-emitters-shape-path/browser/EmittersPathShape.js","../node_modules/@tsparticles/plugin-emitters-shape-path/browser/Options/Classes/EmittersPathShapeOptions.js","../node_modules/@tsparticles/plugin-emitters-shape-path/browser/EmittersPathShapeGenerator.js","../node_modules/@tsparticles/plugin-emitters/browser/EmitterShapeBase.js"],"sourcesContent":["import { getRandom } from \"@tsparticles/engine\";\nconst maxAttempts = 100, half = 0.5;\nexport function generateRandomPointWithinPath(ctx, path, center, size) {\n    let randomPoint = null;\n    for (let attempts = 0; attempts < maxAttempts; attempts++) {\n        const tmpPoint = {\n            x: center.x + getRandom() * size.width - size.width * half,\n            y: center.y + getRandom() * size.height - size.height * half,\n        };\n        if (ctx.isPointInPath(path, tmpPoint.x, tmpPoint.y)) {\n            randomPoint = tmpPoint;\n            break;\n        }\n    }\n    return randomPoint;\n}\nexport function generateRandomPointOnPathPerimeter(ctx, path, center, size) {\n    let randomPoint = null;\n    for (let attempts = 0; attempts < maxAttempts; attempts++) {\n        const tmpPoint = {\n            x: center.x + getRandom() * size.width - size.width * half,\n            y: center.y + getRandom() * size.height - size.height * half,\n        };\n        if (ctx.isPointInStroke(path, tmpPoint.x, tmpPoint.y)) {\n            randomPoint = tmpPoint;\n            break;\n        }\n    }\n    return randomPoint;\n}\n","import { EmitterShapeBase } from \"@tsparticles/plugin-emitters\";\nimport { errorPrefix, percentDenominator } from \"@tsparticles/engine\";\nimport { generateRandomPointOnPathPerimeter, generateRandomPointWithinPath } from \"./utils.js\";\nconst half = 0.5;\nexport class EmittersPathShape extends EmitterShapeBase {\n    constructor(position, size, fill, options) {\n        super(position, size, fill, options);\n        const ctx = document.createElement(\"canvas\").getContext(\"2d\");\n        if (!ctx) {\n            throw new Error(`${errorPrefix} No 2d context available`);\n        }\n        this.checkContext = ctx;\n        this.points = options.points;\n        const pathData = this.points, path = new Path2D(), offset = {\n            x: position.x - size.width * half,\n            y: position.y - size.height * half,\n        };\n        for (const [index, point] of pathData.entries()) {\n            const coords = {\n                x: offset.x + (point.x * size.width) / percentDenominator,\n                y: offset.y + (point.y * size.height) / percentDenominator,\n            };\n            if (!index) {\n                path.moveTo(coords.x, coords.y);\n            }\n            else {\n                path.lineTo(coords.x, coords.y);\n            }\n        }\n        const firstIndex = 0, firstPathData = pathData[firstIndex];\n        if (firstPathData) {\n            const coords = {\n                x: offset.x + (firstPathData.x * size.width) / percentDenominator,\n                y: offset.y + (firstPathData.y * size.height) / percentDenominator,\n            };\n            path.lineTo(coords.x, coords.y);\n        }\n        this.path = path;\n    }\n    async init() {\n    }\n    async randomPosition() {\n        const ctx = this.checkContext, position = this.position, size = this.size, fill = this.fill, path = this.path, res = fill\n            ? generateRandomPointWithinPath(ctx, path, position, size)\n            : generateRandomPointOnPathPerimeter(ctx, path, position, size);\n        return Promise.resolve(res ? { position: res } : null);\n    }\n    resize(position, size) {\n        super.resize(position, size);\n        const pathData = this.points, path = new Path2D(), offset = {\n            x: position.x - size.width * half,\n            y: position.y - size.height * half,\n        };\n        for (const [index, point] of pathData.entries()) {\n            const coords = {\n                x: offset.x + (point.x * size.width) / percentDenominator,\n                y: offset.y + (point.y * size.height) / percentDenominator,\n            };\n            if (!index) {\n                path.moveTo(coords.x, coords.y);\n            }\n            else {\n                path.lineTo(coords.x, coords.y);\n            }\n        }\n        const firstIndex = 0, firstPathData = pathData[firstIndex];\n        if (firstPathData) {\n            const coords = {\n                x: offset.x + (firstPathData.x * size.width) / percentDenominator,\n                y: offset.y + (firstPathData.y * size.height) / percentDenominator,\n            };\n            path.lineTo(coords.x, coords.y);\n        }\n        this.path = path;\n    }\n}\n","const defaultPosition = { x: 50, y: 50 };\nexport class EmittersPathShapeOptions {\n    constructor() {\n        this.points = [];\n    }\n    load(data) {\n        if (!data) {\n            return;\n        }\n        if (data.points !== undefined) {\n            this.points = data.points.map((t) => ({ x: t.x ?? defaultPosition.x, y: t.y ?? defaultPosition.y }));\n        }\n    }\n}\n","import { EmittersPathShape } from \"./EmittersPathShape.js\";\nimport { EmittersPathShapeOptions } from \"./Options/Classes/EmittersPathShapeOptions.js\";\nexport class EmittersPathShapeGenerator {\n    generate(position, size, fill, options) {\n        const shapeOptions = new EmittersPathShapeOptions();\n        shapeOptions.load(options);\n        return new EmittersPathShape(position, size, fill, shapeOptions);\n    }\n}\n","export class EmitterShapeBase {\n    constructor(position, size, fill, options) {\n        this.position = position;\n        this.size = size;\n        this.fill = fill;\n        this.options = options;\n    }\n    resize(position, size) {\n        this.position = position;\n        this.size = size;\n    }\n}\n"],"names":["half","EmittersPathShape","EmitterShapeBase","constructor","position","size","fill","options","super","ctx","document","createElement","getContext","Error","concat","errorPrefix","this","checkContext","points","pathData","path","Path2D","offset","x","width","y","height","index","point","entries","coords","percentDenominator","lineTo","moveTo","firstPathData","init","randomPosition","res","center","randomPoint","attempts","tmpPoint","getRandom","isPointInPath","generateRandomPointWithinPath","isPointInStroke","generateRandomPointOnPathPerimeter","Promise","resolve","resize","defaultPosition","EmittersPathShapeOptions","load","data","undefined","map","t","_t$x","_t$y","EmittersPathShapeGenerator","generate","shapeOptions"],"sourceRoot":""}