{"version":3,"file":"static/js/9508.043a8b98.chunk.js","mappings":"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","sources":["../node_modules/@tsparticles/plugin-poisson-disc/browser/PoissonDisc.js","../node_modules/@tsparticles/plugin-poisson-disc/browser/PoissonInstance.js"],"sourcesContent":["import { getDistance, getRandom } from \"@tsparticles/engine\";\nconst double = 2, doublePI = Math.PI * double;\nexport class PoissonDisc {\n    constructor(size, radius, retries, dimensions, firstPoint) {\n        this.size = { ...size };\n        this.radius = radius;\n        this.retries = retries;\n        this.dimensions = dimensions;\n        this.cellSize = Math.floor(this.radius / Math.sqrt(this.dimensions));\n        this.cols = Math.floor(this.size.width / this.cellSize);\n        this.rows = Math.floor(this.size.height / this.cellSize);\n        this.points = [];\n        this.active = [];\n        this.grid = [];\n        this.firstPoint = firstPoint ? { ...firstPoint } : undefined;\n        this.reset();\n    }\n    addPoint(inputPoint) {\n        const point = {\n            position: { ...inputPoint },\n            gridPosition: {\n                x: Math.floor(inputPoint.x / this.cellSize),\n                y: Math.floor(inputPoint.y / this.cellSize),\n            },\n        }, pointIndex = this.points.length;\n        this.points.push(point);\n        this.grid[point.gridPosition.y][point.gridPosition.x] = pointIndex;\n        this.active.push(pointIndex);\n    }\n    getRandom(min, max) {\n        return Math.floor(getRandom() * (max - min)) + min;\n    }\n    initialiseGrid() {\n        for (let y = 0; y <= this.rows; y++) {\n            this.grid[y] = [];\n            for (let x = 0; x <= this.cols; x++) {\n                this.grid[y][x] = -1;\n            }\n        }\n    }\n    reset() {\n        this.points = [];\n        this.active = [];\n        this.grid = [];\n        this.initialiseGrid();\n        if (this.firstPoint) {\n            this.addPoint(this.firstPoint);\n        }\n        else {\n            const minCoordinate = 0;\n            this.addPoint({\n                x: this.getRandom(minCoordinate, this.size.width),\n                y: this.getRandom(minCoordinate, this.size.height),\n            });\n        }\n    }\n    async run() {\n        this.reset();\n        const minCount = 0, step = 1;\n        while (this.active.length > minCount) {\n            await this.steps(step);\n        }\n    }\n    async steps(steps) {\n        const minCount = 0;\n        for (let i = 0; i < steps; i++) {\n            if (this.active.length <= minCount) {\n                continue;\n            }\n            await this._step();\n        }\n    }\n    _getNewPoint(currentPoint, tries) {\n        const minCoordinate = 0, gridMinValue = 0, maxNeighbourIndex = 1, newAngle = tries * (doublePI / this.retries), newDist = this.getRandom(this.radius, this.radius * double), offset = {\n            x: Math.cos(newAngle) * newDist,\n            y: Math.sin(newAngle) * newDist,\n        }, newPoint = {\n            x: Math.floor(currentPoint.position.x + offset.x),\n            y: Math.floor(currentPoint.position.y + offset.y),\n        }, newGridCoords = {\n            x: Math.floor(newPoint.x / this.cellSize),\n            y: Math.floor(newPoint.y / this.cellSize),\n        };\n        if (newPoint.x > minCoordinate &&\n            newPoint.x < this.size.width &&\n            newPoint.y > minCoordinate &&\n            newPoint.y < this.size.height) {\n            if (this.grid[newGridCoords.y][newGridCoords.x] < gridMinValue) {\n                for (let i = -1; i <= maxNeighbourIndex; i++) {\n                    for (let j = -1; j <= maxNeighbourIndex; j++) {\n                        const neighbourGrid = {\n                            x: newGridCoords.x + j,\n                            y: newGridCoords.y + i,\n                        };\n                        if (neighbourGrid.x >= minCoordinate &&\n                            neighbourGrid.y >= minCoordinate &&\n                            neighbourGrid.x < this.cols &&\n                            neighbourGrid.y < this.rows &&\n                            (neighbourGrid.x !== newGridCoords.x || neighbourGrid.y !== newGridCoords.y)) {\n                            if (this.grid[neighbourGrid.y][neighbourGrid.x] >= gridMinValue) {\n                                const neighbourIndex = this.grid[neighbourGrid.y][neighbourGrid.x], neighbour = this.points[neighbourIndex], dist = getDistance(newPoint, neighbour.position);\n                                if (dist < this.radius) {\n                                    return;\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n            else {\n                return;\n            }\n        }\n        else {\n            return;\n        }\n        return newPoint;\n    }\n    async _step() {\n        const minCount = 0, randomActive = this.getRandom(minCount, this.active.length);\n        return new Promise((resolve) => {\n            let foundNewPoint = false;\n            for (let tries = 0; tries < this.retries; tries++) {\n                const newPoint = this._getNewPoint(this.points[this.active[randomActive]], tries);\n                if (newPoint) {\n                    foundNewPoint = true;\n                    this.addPoint(newPoint);\n                    break;\n                }\n            }\n            if (!foundNewPoint) {\n                const deleteCount = 1;\n                this.active.splice(randomActive, deleteCount);\n            }\n            resolve();\n        });\n    }\n}\n","import { getRangeMax } from \"@tsparticles/engine\";\nimport { PoissonDisc } from \"./PoissonDisc.js\";\nexport class PoissonInstance {\n    constructor(container, engine) {\n        this._container = container;\n        this._engine = engine;\n        this._currentIndex = 0;\n    }\n    async init() {\n        await this._initData();\n    }\n    particlePosition(position) {\n        const container = this._container, options = container.actualOptions.poisson;\n        if (!this.poissonDisc || !(options?.enable ?? false) || this._currentIndex >= this.poissonDisc.points.length) {\n            return;\n        }\n        return position ?? this.poissonDisc?.points[this._currentIndex++]?.position;\n    }\n    resize() {\n        const container = this._container, options = container.actualOptions.poisson;\n        if (!(options?.enable ?? false)) {\n            return;\n        }\n        if (this.redrawTimeout) {\n            clearTimeout(this.redrawTimeout);\n        }\n        const timeout = 250;\n        this.redrawTimeout = window.setTimeout(() => {\n            void (async () => {\n                await this._initData();\n                await container.particles.redraw();\n            })();\n        }, timeout);\n    }\n    stop() {\n        delete this.poissonDisc;\n    }\n    async _initData() {\n        const container = this._container, poissonOptions = container.actualOptions.poisson, particlesOptions = container.actualOptions.particles, canvasSize = container.canvas.size, pixelRatio = container.retina.pixelRatio;\n        if (!poissonOptions?.enable) {\n            return;\n        }\n        this._currentIndex = 0;\n        this.poissonDisc = new PoissonDisc(canvasSize, poissonOptions.radius\n            ? poissonOptions.radius * pixelRatio\n            : Math.max(getRangeMax(particlesOptions.size.value) * pixelRatio, Math.sqrt((canvasSize.width * canvasSize.height) / particlesOptions.number.value)), poissonOptions.retries, poissonOptions.dimensions);\n        const noSteps = 0;\n        if (poissonOptions.steps > noSteps) {\n            await this.poissonDisc.steps(poissonOptions.steps);\n        }\n        else {\n            await this.poissonDisc.run();\n        }\n    }\n}\n"],"names":["doublePI","Math","PI","PoissonDisc","constructor","size","radius","retries","dimensions","firstPoint","this","cellSize","floor","sqrt","cols","width","rows","height","points","active","grid","undefined","reset","addPoint","inputPoint","point","position","gridPosition","x","y","pointIndex","length","push","getRandom","min","max","initialiseGrid","minCoordinate","run","steps","i","_step","_getNewPoint","currentPoint","tries","newAngle","newDist","offset","cos","sin","newPoint","newGridCoords","j","neighbourGrid","neighbourIndex","neighbour","getDistance","randomActive","Promise","resolve","foundNewPoint","deleteCount","splice","PoissonInstance","container","engine","_container","_engine","_currentIndex","init","_initData","particlePosition","_options$enable","_this$poissonDisc","options","actualOptions","poisson","poissonDisc","enable","resize","_options$enable2","redrawTimeout","clearTimeout","window","setTimeout","particles","redraw","stop","poissonOptions","particlesOptions","canvasSize","canvas","pixelRatio","retina","getRangeMax","value","number"],"sourceRoot":""}