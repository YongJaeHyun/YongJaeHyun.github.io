{"version":3,"file":"static/js/4368.a523b540.chunk.js","mappings":"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","sources":["../node_modules/@tsparticles/effect-trail/browser/TrailDrawer.js"],"sourcesContent":["import { getRangeValue, } from \"@tsparticles/engine\";\nconst double = 2, minTrailLength = 2, trailLengthOffset = 1, noItems = 0, half = 0.5, minWidth = -1, defaultLength = 10, defaultAlpha = 1;\nexport class TrailDrawer {\n    async draw(data) {\n        const { context, radius, particle } = data, diameter = radius * double, pxRatio = particle.container.retina.pixelRatio, currentPos = particle.getPosition();\n        if (!particle.trail || !particle.trailLength) {\n            return;\n        }\n        const pathLength = particle.trailLength + radius;\n        particle.trail.push({\n            color: context.fillStyle ?? context.strokeStyle,\n            position: {\n                x: currentPos.x,\n                y: currentPos.y,\n            },\n        });\n        if (particle.trail.length < minTrailLength) {\n            return;\n        }\n        while (particle.trail.length > pathLength) {\n            particle.trail.shift();\n        }\n        const trailLength = Math.min(particle.trail.length, pathLength), offsetPos = {\n            x: currentPos.x,\n            y: currentPos.y,\n        }, canvasSize = {\n            width: particle.container.canvas.size.width + diameter,\n            height: particle.container.canvas.size.height + diameter,\n        };\n        let lastPos = particle.trail[trailLength - trailLengthOffset].position;\n        const defaultTransform = {\n            a: 1,\n            b: 0,\n            c: 0,\n            d: 1,\n        };\n        context.setTransform(defaultTransform.a, defaultTransform.b, defaultTransform.c, defaultTransform.d, currentPos.x, currentPos.y);\n        for (let i = trailLength; i > noItems; i--) {\n            const step = particle.trail[i - trailLengthOffset], position = step.position;\n            context.beginPath();\n            context.moveTo(lastPos.x - offsetPos.x, lastPos.y - offsetPos.y);\n            const warp = {\n                x: (lastPos.x + canvasSize.width) % canvasSize.width,\n                y: (lastPos.y + canvasSize.height) % canvasSize.height,\n            };\n            if (Math.abs(lastPos.x - position.x) > canvasSize.width * half ||\n                Math.abs(lastPos.y - position.y) > canvasSize.height * half) {\n                lastPos = position;\n                continue;\n            }\n            context.lineTo((Math.abs(lastPos.x - position.x) > canvasSize.width * half ? warp.x : position.x) - offsetPos.x, (Math.abs(lastPos.y - position.y) > canvasSize.height * half ? warp.y : position.y) - offsetPos.y);\n            const width = Math.max((i / trailLength) * diameter, pxRatio, particle.trailMinWidth ?? minWidth), oldAlpha = context.globalAlpha;\n            context.globalAlpha = particle.trailFade ? i / trailLength : defaultAlpha;\n            context.lineWidth = particle.trailMaxWidth ? Math.min(width, particle.trailMaxWidth) : width;\n            context.strokeStyle = step.color;\n            context.stroke();\n            context.globalAlpha = oldAlpha;\n            lastPos = position;\n        }\n        const { transformData } = data;\n        context.setTransform(transformData.a, transformData.b, transformData.c, transformData.d, currentPos.x, currentPos.y);\n        await Promise.resolve();\n    }\n    async particleInit(container, particle) {\n        particle.trail = [];\n        const effectData = particle.effectData;\n        particle.trailFade = effectData?.fade ?? true;\n        particle.trailLength = getRangeValue(effectData?.length ?? defaultLength) * container.retina.pixelRatio;\n        particle.trailMaxWidth = effectData?.maxWidth\n            ? getRangeValue(effectData.maxWidth) * container.retina.pixelRatio\n            : undefined;\n        particle.trailMinWidth = effectData?.minWidth\n            ? getRangeValue(effectData.minWidth) * container.retina.pixelRatio\n            : undefined;\n        await Promise.resolve();\n    }\n}\n"],"names":["half","TrailDrawer","draw","data","_context$fillStyle","context","radius","particle","diameter","pxRatio","container","retina","pixelRatio","currentPos","getPosition","trail","trailLength","pathLength","push","color","fillStyle","strokeStyle","position","x","y","length","shift","Math","min","offsetPos","canvasSize","canvas","size","width","height","lastPos","defaultTransform","setTransform","i","_particle$trailMinWid","step","beginPath","moveTo","warp","abs","lineTo","max","trailMinWidth","oldAlpha","globalAlpha","trailFade","lineWidth","trailMaxWidth","stroke","transformData","a","b","c","d","Promise","resolve","particleInit","_effectData$fade","_effectData$length","effectData","fade","getRangeValue","maxWidth","undefined","minWidth"],"sourceRoot":""}