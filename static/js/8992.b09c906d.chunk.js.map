{"version":3,"file":"static/js/8992.b09c906d.chunk.js","mappings":"yJAEA,MAAMA,EAAc,+FACb,MAAMC,EACTC,WAAAA,GACIC,KAAKC,gBAAkB,IAAIC,GAC/B,CACAC,OAAAA,GACI,IAAK,MAAOC,EAAKC,KAAcL,KAAKC,gBAC5BI,aAAqBC,cACZ,OAATD,QAAS,IAATA,GAAAA,EAAWE,QACXP,KAAKC,gBAAgBO,OAAOJ,GAGxC,CACA,UAAMK,CAAKC,GACP,MAAM,UAAEC,SAAoB,+BAC5BA,EAAUD,EACd,CACA,UAAME,CAAKC,GACP,MAAMC,EAAUD,EAAUE,cAC1B,IAAKC,EAAAA,EAAWC,MAAMC,IAAMC,EAAAA,EAAAA,IAAUD,EAAGJ,EAAQM,UAAUC,MAAMC,QAC7D,OAEJ,MAAMC,EAAW,EAACC,EAAAA,EAAAA,IAAS3B,IAAe4B,EAAeT,EAAAA,EACpDU,KAAKR,GAAMJ,EAAQM,UAAUC,MAAMP,QAAQI,KAC3CD,MAAMC,KAAQA,IACfO,IACAE,EAAAA,EAAAA,IAA0BF,GAAeJ,IACjCA,EAAMO,MACNL,EAASM,MAAKL,EAAAA,EAAAA,IAASH,EAAMO,MACjC,UAGFE,QAAQC,IAAIR,EACtB,CACAS,eAAAA,CAAgBC,UACLA,EAAS5B,SACpB,CACA,kBAAM6B,CAAarB,EAAWoB,GAAU,IAAAE,EACpC,MAAkBC,EAAYH,EAASG,UACvC,GAAc,OAATA,QAAS,IAATA,IAAAA,EAAWC,MACZ,OAEJ,MAAMC,GAAQC,EAAAA,EAAAA,IAAyBH,EAAUC,MAAOJ,EAASO,iBAAkBZ,EAAqB,QAAjBO,EAAGC,EAAUR,YAAI,IAAAO,EAAAA,EAAItC,EAC5G,IAAKyC,EACD,OAEJ,MAAMlC,EAAM,GAAHqC,OAAMH,EAAK,KAAAG,OAAIb,GAAQc,EAAe1C,KAAKC,gBAAgB0C,IAAIvC,GACxE,GAAIsC,EAEA,YADAT,EAAS5B,UAAYqC,GAGzB,MAAME,EAbS,GAaIC,EAAAA,EAAAA,IAAYZ,EAASa,KAAKT,OAC7C,IAAIhC,EACJ,MAAM0C,GAAUF,EAAAA,EAAAA,IAAYZ,EAASa,KAAKT,OAC1C,GAA+B,qBAApBW,gBAAiC,CACxC,MAAMC,EAAS,IAAID,gBAAgBJ,EAAYA,GAAaM,EAAUD,EAAOE,WAAW,MACxF,IAAKD,EACD,OAEJA,EAAQtB,KAAO,OAAHa,OArBD,EAqBWM,EAAgB,OAAAN,OAAMb,GAC5CsB,EAAQE,aAAe,SACvBF,EAAQG,UAAY,SACpBH,EAAQI,SAAShB,EAAOS,EAASA,GACjC1C,EAAY4C,EAAOM,uBACvB,KACK,CACD,MAAMN,EAASO,SAASC,cAAc,UACtCR,EAAOS,MAAQd,EACfK,EAAOU,OAASf,EAChB,MAAMM,EAAUD,EAAOE,WAAW,MAClC,IAAKD,EACD,OAEJA,EAAQtB,KAAO,OAAHa,OAnCD,EAmCWM,EAAgB,OAAAN,OAAMb,GAC5CsB,EAAQE,aAAe,SACvBF,EAAQG,UAAY,SACpBH,EAAQI,SAAShB,EAAOS,EAASA,GACjC1C,EAAY4C,CAChB,CACAjD,KAAKC,gBAAgB2D,IAAIxD,EAAKC,GAC9B4B,EAAS5B,UAAYA,QACfyB,QAAQ+B,SAClB,E","sources":["../node_modules/@tsparticles/shape-emoji/browser/EmojiDrawer.js"],"sourcesContent":["import { executeOnSingleOrMultiple, getRangeMax, isInArray, itemFromSingleOrMultiple, loadFont, } from \"@tsparticles/engine\";\nimport { validTypes } from \"./Constants.js\";\nconst defaultFont = '\"Twemoji Mozilla\", Apple Color Emoji, \"Segoe UI Emoji\", \"Noto Color Emoji\", \"EmojiOne Color\"';\nexport class EmojiDrawer {\n    constructor() {\n        this._emojiShapeDict = new Map();\n    }\n    destroy() {\n        for (const [key, emojiData] of this._emojiShapeDict) {\n            if (emojiData instanceof ImageBitmap) {\n                emojiData?.close();\n                this._emojiShapeDict.delete(key);\n            }\n        }\n    }\n    async draw(data) {\n        const { drawEmoji } = await import(\"./Utils.js\");\n        drawEmoji(data);\n    }\n    async init(container) {\n        const options = container.actualOptions;\n        if (!validTypes.find((t) => isInArray(t, options.particles.shape.type))) {\n            return;\n        }\n        const promises = [loadFont(defaultFont)], shapeOptions = validTypes\n            .map((t) => options.particles.shape.options[t])\n            .find((t) => !!t);\n        if (shapeOptions) {\n            executeOnSingleOrMultiple(shapeOptions, (shape) => {\n                if (shape.font) {\n                    promises.push(loadFont(shape.font));\n                }\n            });\n        }\n        await Promise.all(promises);\n    }\n    particleDestroy(particle) {\n        delete particle.emojiData;\n    }\n    async particleInit(container, particle) {\n        const double = 2, shapeData = particle.shapeData;\n        if (!shapeData?.value) {\n            return;\n        }\n        const emoji = itemFromSingleOrMultiple(shapeData.value, particle.randomIndexData), font = shapeData.font ?? defaultFont;\n        if (!emoji) {\n            return;\n        }\n        const key = `${emoji}_${font}`, existingData = this._emojiShapeDict.get(key);\n        if (existingData) {\n            particle.emojiData = existingData;\n            return;\n        }\n        const canvasSize = getRangeMax(particle.size.value) * double;\n        let emojiData;\n        const maxSize = getRangeMax(particle.size.value);\n        if (typeof OffscreenCanvas !== \"undefined\") {\n            const canvas = new OffscreenCanvas(canvasSize, canvasSize), context = canvas.getContext(\"2d\");\n            if (!context) {\n                return;\n            }\n            context.font = `400 ${maxSize * double}px ${font}`;\n            context.textBaseline = \"middle\";\n            context.textAlign = \"center\";\n            context.fillText(emoji, maxSize, maxSize);\n            emojiData = canvas.transferToImageBitmap();\n        }\n        else {\n            const canvas = document.createElement(\"canvas\");\n            canvas.width = canvasSize;\n            canvas.height = canvasSize;\n            const context = canvas.getContext(\"2d\");\n            if (!context) {\n                return;\n            }\n            context.font = `400 ${maxSize * double}px ${font}`;\n            context.textBaseline = \"middle\";\n            context.textAlign = \"center\";\n            context.fillText(emoji, maxSize, maxSize);\n            emojiData = canvas;\n        }\n        this._emojiShapeDict.set(key, emojiData);\n        particle.emojiData = emojiData;\n        await Promise.resolve();\n    }\n}\n"],"names":["defaultFont","EmojiDrawer","constructor","this","_emojiShapeDict","Map","destroy","key","emojiData","ImageBitmap","close","delete","draw","data","drawEmoji","init","container","options","actualOptions","validTypes","find","t","isInArray","particles","shape","type","promises","loadFont","shapeOptions","map","executeOnSingleOrMultiple","font","push","Promise","all","particleDestroy","particle","particleInit","_shapeData$font","shapeData","value","emoji","itemFromSingleOrMultiple","randomIndexData","concat","existingData","get","canvasSize","getRangeMax","size","maxSize","OffscreenCanvas","canvas","context","getContext","textBaseline","textAlign","fillText","transferToImageBitmap","document","createElement","width","height","set","resolve"],"sourceRoot":""}