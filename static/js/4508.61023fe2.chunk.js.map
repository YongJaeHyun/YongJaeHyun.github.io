{"version":3,"file":"static/js/4508.61023fe2.chunk.js","mappings":"mJACA,MAAMA,EAAY,IAkEX,SAASC,EAASC,GACrB,MAAMC,EAAS,CAAEC,EAAG,EAAGC,EAAG,EAAGC,EAAG,GAAiBC,EAC1CL,EAAIM,EADkC,GAAID,EAE1CL,EAAIO,EAAIC,EAAAA,GAFkCH,EAG1CL,EAAIS,EAAID,EAAAA,GACoBE,EAAIL,EAAeA,EAAcM,EAAID,GAA5D,EAA0EE,KAAKC,IAAKR,EAAhE,EAApB,IACZ,IAAIS,EA4CJ,GA1CIT,GADoB,GACYA,GADJ,EAE5BS,EAAU,CACNV,EAAGM,EACHP,EAAGQ,EACHT,EAAG,GAGFG,EAR8C,GAQfA,GARuB,EAS3DS,EAAU,CACNV,EAAGO,EACHR,EAAGO,EACHR,EAAG,GAGFG,EAf6E,GAe9CA,GAfsD,EAgB1FS,EAAU,CACNV,EAAG,EACHD,EAAGO,EACHR,EAAGS,GAGFN,EAtB4G,GAsB7EA,GAtBqF,EAuBzHS,EAAU,CACNV,EAAG,EACHD,EAAGQ,EACHT,EAAGQ,GAGFL,EA7B2I,GA6B5GA,GA7BoH,EA8BxJS,EAAU,CACNV,EAAGO,EACHR,EAAG,EACHD,EAAGQ,GAGFL,EApC0K,GAoC3IA,GApCmJ,IAqCvLS,EAAU,CACNV,EAAGM,EACHP,EAAG,EACHD,EAAGS,IAGPG,EAAS,CACT,MAAMC,EAAIV,EAAeK,EACzBT,EAAOG,EAAIQ,KAAKI,OAAOF,EAAQV,EAAIW,GAAKjB,GACxCG,EAAOE,EAAIS,KAAKI,OAAOF,EAAQX,EAAIY,GAAKjB,GACxCG,EAAOC,EAAIU,KAAKI,OAAOF,EAAQZ,EAAIa,GAAKjB,EAC5C,CACA,OAAOG,CACX,CAOO,MAAMgB,EACTC,WAAAA,GACIC,KAAKC,IAAM,MACXD,KAAKE,aAAe,KACxB,CACAC,WAAAA,CAAYC,GAAO,IAAAC,EACf,MAAgCC,EAAyB,QAAjBD,EAArBD,EAAMG,MAA6B1B,WAAG,IAAAwB,EAAAA,EAAID,EAAMG,MACnE,QAAmBC,IAAfF,EAASnB,QAAkCqB,IAAfF,EAAShB,EACrC,OAAOV,EAAS0B,EAExB,CACAG,gBAAAA,CAAiBL,GAAO,IAAAM,EACpB,MAAgCJ,EAAyB,QAAjBI,EAArBN,EAAMG,MAA6B1B,WAAG,IAAA6B,EAAAA,EAAIN,EAAMG,MACnE,QAAmBC,IAAfF,EAASnB,QAAkCqB,IAAfF,EAAShB,EACrC,OAAOV,EAAS,CACZO,GAAGwB,EAAAA,EAAAA,IAAcL,EAASnB,GAC1BC,GAAGuB,EAAAA,EAAAA,IAAcL,EAASlB,GAC1BE,GAAGqB,EAAAA,EAAAA,IAAcL,EAAShB,IAGtC,CACAsB,WAAAA,CAAYC,GACR,IAAKA,EAAMC,WAAW,OAClB,OAEJ,MAAqFhC,EAAvE,yEAAsFiC,KAAKF,GAAwBG,EAC1H,EAD0HA,EAE1H,EAF0HA,EAG1H,EAH0HA,EAI1H,EAEP,OAAOlC,EApCJ,CACHmC,GAFmBC,EAsCF,CACTD,EAAGnC,EAAOqC,OAR4G,GAQtFC,EAAAA,EAAAA,IAAWtC,EAAOkC,IAHxC,EAIV7B,EAAGkC,SAASvC,EAAOkC,GAJE,IAKrB5B,EAAGiC,SAASvC,EAAOkC,GALE,IAMrB1B,EAAG+B,SAASvC,EAAOkC,GANE,MAlCrBC,KACLrC,EAASsC,SAyCNV,EA5CP,IAAoBU,CA6CvB,E","sources":["../node_modules/@tsparticles/plugin-hsv-color/browser/HsvColorManager.js"],"sourcesContent":["import { getRangeValue, getStyleFromHsl, parseAlpha, percentDenominator, } from \"@tsparticles/engine\";\nconst rgbFactor = 255, double = 2, half = 0.5;\nexport function rgbToHsv(rgb) {\n    const rgbPercent = {\n        r: rgb.r / rgbFactor,\n        g: rgb.g / rgbFactor,\n        b: rgb.b / rgbFactor,\n    }, xMax = Math.max(rgbPercent.r, rgbPercent.g, rgbPercent.b), xMin = Math.min(rgbPercent.r, rgbPercent.g, rgbPercent.b), v = xMax, c = xMax - xMin;\n    let h = 0;\n    const phaseOffset = {\n        r: 0,\n        g: 2,\n        b: 4,\n    }, phaseValue = 60;\n    if (v === rgbPercent.r) {\n        h = phaseValue * (phaseOffset.r + (rgbPercent.g - rgbPercent.b) / c);\n    }\n    else if (v === rgbPercent.g) {\n        h = phaseValue * (phaseOffset.g + (rgbPercent.b - rgbPercent.r) / c);\n    }\n    else if (v === rgbPercent.b) {\n        h = phaseValue * (phaseOffset.b + (rgbPercent.r - rgbPercent.g) / c);\n    }\n    const defaultSaturation = 0, s = !v ? defaultSaturation : c / v;\n    return {\n        h,\n        s: s * percentDenominator,\n        v: v * percentDenominator,\n    };\n}\nexport function rgbaToHsva(rgba) {\n    return {\n        a: rgba.a,\n        ...rgbToHsv(rgba),\n    };\n}\nexport function getStyleFromHsv(color, opacity) {\n    return getStyleFromHsl(hsvToHsl(color), opacity);\n}\nexport function hslToHsv(hsl) {\n    const l = hsl.l / percentDenominator, sl = hsl.s / percentDenominator, offset = 1, noValue = 0, v = l + sl * Math.min(l, offset - l), sv = !v ? noValue : double * (offset - l / v);\n    return {\n        h: hsl.h,\n        s: sv * percentDenominator,\n        v: v * percentDenominator,\n    };\n}\nexport function hslaToHsva(hsla) {\n    return {\n        a: hsla.a,\n        ...hslToHsv(hsla),\n    };\n}\nexport function hsvToHsl(hsv) {\n    const v = hsv.v / percentDenominator, sv = hsv.s / percentDenominator, offset = 1, noValue = 0, l = v * (offset - sv * half), sl = !l || l === offset ? noValue : (v - l) / Math.min(l, offset - l);\n    return {\n        h: hsv.h,\n        l: l * percentDenominator,\n        s: sl * percentDenominator,\n    };\n}\nexport function hsvaToHsla(hsva) {\n    return {\n        a: hsva.a,\n        ...hsvToHsl(hsva),\n    };\n}\nexport function hsvToRgb(hsv) {\n    const result = { b: 0, g: 0, r: 0 }, phase = 60, hsvPercent = {\n        h: hsv.h / phase,\n        s: hsv.s / percentDenominator,\n        v: hsv.v / percentDenominator,\n    }, offset = 1, hPercentFactor = 2, c = hsvPercent.v * hsvPercent.s, x = c * (offset - Math.abs((hsvPercent.h % hPercentFactor) - offset));\n    let tempRgb;\n    const cxzRange = { min: 0, max: 1 }, xczRange = { min: 1, max: 2 }, zcxRange = { min: 2, max: 3 }, zxcRange = { min: 3, max: 4 }, xzcRange = { min: 4, max: 5 }, czxRange = { min: 5, max: 6 };\n    if (hsvPercent.h >= cxzRange.min && hsvPercent.h <= cxzRange.max) {\n        tempRgb = {\n            r: c,\n            g: x,\n            b: 0,\n        };\n    }\n    else if (hsvPercent.h > xczRange.min && hsvPercent.h <= xczRange.max) {\n        tempRgb = {\n            r: x,\n            g: c,\n            b: 0,\n        };\n    }\n    else if (hsvPercent.h > zcxRange.min && hsvPercent.h <= zcxRange.max) {\n        tempRgb = {\n            r: 0,\n            g: c,\n            b: x,\n        };\n    }\n    else if (hsvPercent.h > zxcRange.min && hsvPercent.h <= zxcRange.max) {\n        tempRgb = {\n            r: 0,\n            g: x,\n            b: c,\n        };\n    }\n    else if (hsvPercent.h > xzcRange.min && hsvPercent.h <= xzcRange.max) {\n        tempRgb = {\n            r: x,\n            g: 0,\n            b: c,\n        };\n    }\n    else if (hsvPercent.h > czxRange.min && hsvPercent.h <= czxRange.max) {\n        tempRgb = {\n            r: c,\n            g: 0,\n            b: x,\n        };\n    }\n    if (tempRgb) {\n        const m = hsvPercent.v - c;\n        result.r = Math.floor((tempRgb.r + m) * rgbFactor);\n        result.g = Math.floor((tempRgb.g + m) * rgbFactor);\n        result.b = Math.floor((tempRgb.b + m) * rgbFactor);\n    }\n    return result;\n}\nexport function hsvaToRgba(hsva) {\n    return {\n        a: hsva.a,\n        ...hsvToRgb(hsva),\n    };\n}\nexport class HsvColorManager {\n    constructor() {\n        this.key = \"hsv\";\n        this.stringPrefix = \"hsv\";\n    }\n    handleColor(color) {\n        const colorValue = color.value, hsvColor = colorValue.hsv ?? color.value;\n        if (hsvColor.h !== undefined && hsvColor.v !== undefined) {\n            return hsvToRgb(hsvColor);\n        }\n    }\n    handleRangeColor(color) {\n        const colorValue = color.value, hsvColor = colorValue.hsv ?? color.value;\n        if (hsvColor.h !== undefined && hsvColor.v !== undefined) {\n            return hsvToRgb({\n                h: getRangeValue(hsvColor.h),\n                s: getRangeValue(hsvColor.s),\n                v: getRangeValue(hsvColor.v),\n            });\n        }\n    }\n    parseString(input) {\n        if (!input.startsWith(\"hsv\")) {\n            return;\n        }\n        const regex = /hsva?\\(\\s*(\\d+)Â°\\s*,\\s*(\\d+)%\\s*,\\s*(\\d+)%\\s*(,\\s*([\\d.%]+)\\s*)?\\)/i, result = regex.exec(input), fullLength = 4, indexes = {\n            h: 1,\n            s: 2,\n            v: 3,\n            a: 5,\n        }, defaultAlpha = 1, radix = 10;\n        return result\n            ? hsvaToRgba({\n                a: result.length > fullLength ? parseAlpha(result[indexes.a]) : defaultAlpha,\n                h: parseInt(result[indexes.h], radix),\n                s: parseInt(result[indexes.s], radix),\n                v: parseInt(result[indexes.v], radix),\n            })\n            : undefined;\n    }\n}\n"],"names":["rgbFactor","hsvToRgb","hsv","result","b","g","r","hsvPercent","h","s","percentDenominator","v","c","x","Math","abs","tempRgb","m","floor","HsvColorManager","constructor","this","key","stringPrefix","handleColor","color","_colorValue$hsv","hsvColor","value","undefined","handleRangeColor","_colorValue$hsv2","getRangeValue","parseString","input","startsWith","exec","indexes","a","hsva","length","parseAlpha","parseInt"],"sourceRoot":""}