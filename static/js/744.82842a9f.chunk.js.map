{"version":3,"file":"static/js/744.82842a9f.chunk.js","mappings":"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","sources":["../node_modules/@tsparticles/path-svg/browser/SVGPathGenerator.js"],"sourcesContent":["import { Vector, getPosition, getRandom, halfRandom, randomInRange, } from \"@tsparticles/engine\";\nconst defaultSpeed = 1, half = 0.5, minStep = 0, minIndex = 0, minWidth = 0, minScale = 1;\nexport class SVGPathGenerator {\n    constructor() {\n        this._paths = [];\n        this._reverse = false;\n        this._size = { width: 0, height: 0 };\n        this._scale = 1;\n        this._offset = { x: 0, y: 0, mode: \"percent\" };\n        this._width = 0;\n    }\n    generate(particle, delta) {\n        const container = particle.container, pxRatio = container.retina.pixelRatio;\n        if (particle.svgDirection === undefined) {\n            particle.svgDirection = getRandom() > halfRandom ? 0 : 1;\n        }\n        if (particle.svgPathIndex === undefined) {\n            particle.svgPathIndex = Math.floor(Math.random() * this._paths.length);\n        }\n        if (particle.svgSpeed === undefined) {\n            particle.svgSpeed = particle.velocity.mult((particle.retina.moveSpeed ?? defaultSpeed) * half).length;\n        }\n        if (particle.svgStep === undefined) {\n            particle.svgStep = randomInRange({ min: 0, max: this._paths[particle.svgPathIndex].length }) * pxRatio;\n        }\n        if (particle.svgOffset === undefined) {\n            particle.svgOffset = {\n                width: randomInRange({ min: -this._width * half, max: this._width * half }) * pxRatio,\n                height: randomInRange({ min: -this._width * half, max: this._width * half }) * pxRatio,\n            };\n        }\n        if (particle.svgInitialPosition === undefined) {\n            particle.svgInitialPosition = { ...particle.position };\n        }\n        particle.velocity.x = 0;\n        particle.velocity.y = 0;\n        if (particle.svgDirection === 0) {\n            particle.svgStep += particle.svgSpeed * delta.factor;\n        }\n        else {\n            particle.svgStep -= particle.svgSpeed * delta.factor;\n        }\n        let path = this._paths[particle.svgPathIndex];\n        if (path) {\n            const pathLength = path.length, indexOffset = 1;\n            if (particle.svgStep >= pathLength) {\n                particle.svgPathIndex = particle.svgPathIndex + indexOffset;\n                if (particle.svgPathIndex >= this._paths.length) {\n                    if (this._reverse) {\n                        particle.svgPathIndex = this._paths.length - indexOffset;\n                        particle.svgDirection = 1;\n                    }\n                    else {\n                        particle.svgPathIndex = 0;\n                        particle.svgStep = 0;\n                    }\n                }\n            }\n            else if (particle.svgStep <= minStep) {\n                particle.svgPathIndex = particle.svgPathIndex - indexOffset;\n                if (particle.svgPathIndex < minIndex) {\n                    if (this._reverse) {\n                        particle.svgPathIndex = 0;\n                        particle.svgDirection = 0;\n                    }\n                    else {\n                        particle.svgPathIndex = this._paths.length - indexOffset;\n                        path = this._paths[particle.svgPathIndex];\n                        particle.svgStep = path.length;\n                    }\n                }\n            }\n            path = this._paths[particle.svgPathIndex];\n        }\n        if (path) {\n            const pathElement = path.element, pos = pathElement.getPointAtLength(particle.svgStep), canvasSize = particle.container.canvas.size, offset = getPosition(this._offset, canvasSize), scale = this._scale * pxRatio;\n            particle.position.x =\n                (pos.x - this._size.width * half) * scale +\n                    particle.svgInitialPosition.x +\n                    offset.x +\n                    particle.svgOffset.width;\n            particle.position.y =\n                (pos.y - this._size.height * half) * scale +\n                    particle.svgInitialPosition.y +\n                    offset.y +\n                    particle.svgOffset.height;\n        }\n        return Promise.resolve(Vector.origin);\n    }\n    async init(container) {\n        const options = container.actualOptions.particles.move.path.options, position = options.position ?? this._offset;\n        this._reverse = options.reverse ?? this._reverse;\n        this._scale = options.scale ?? minScale;\n        this._offset.x = position.x;\n        this._offset.y = position.y;\n        this._offset.mode = position.mode;\n        this._width = options.width ?? minWidth;\n        if (options.url && !options.path) {\n            const url = options.url;\n            const response = await fetch(url), data = await response.text();\n            const parser = new DOMParser(), doc = parser.parseFromString(data, \"image/svg+xml\"), firstIndex = 0, svg = doc.getElementsByTagName(\"svg\")[firstIndex];\n            let svgPaths = svg.getElementsByTagName(\"path\");\n            if (!svgPaths.length) {\n                svgPaths = doc.getElementsByTagName(\"path\");\n            }\n            this._paths = [];\n            for (let i = 0; i < svgPaths.length; i++) {\n                const path = svgPaths.item(i);\n                if (path) {\n                    this._paths.push({\n                        element: path,\n                        length: path.getTotalLength(),\n                    });\n                }\n            }\n            this._size.height = parseFloat(svg.getAttribute(\"height\") ?? \"0\");\n            this._size.width = parseFloat(svg.getAttribute(\"width\") ?? \"0\");\n        }\n        else if (options.path) {\n            const path = options.path;\n            this._paths = [];\n            for (const item of path.data) {\n                const element = document.createElementNS(\"http://www.w3.org/2000/svg\", \"path\");\n                element.setAttribute(\"d\", item);\n                this._paths.push({\n                    element,\n                    length: element.getTotalLength(),\n                });\n            }\n            this._size.height = path.size.height;\n            this._size.width = path.size.width;\n        }\n    }\n    reset() {\n    }\n    update() {\n    }\n}\n"],"names":["half","SVGPathGenerator","constructor","this","_paths","_reverse","_size","width","height","_scale","_offset","x","y","mode","_width","generate","particle","delta","pxRatio","container","retina","pixelRatio","_particle$retina$move","undefined","svgDirection","getRandom","halfRandom","svgPathIndex","Math","floor","random","length","svgSpeed","velocity","mult","moveSpeed","svgStep","randomInRange","min","max","svgOffset","svgInitialPosition","position","factor","path","pathLength","indexOffset","pos","element","getPointAtLength","canvasSize","canvas","size","offset","getPosition","scale","Promise","resolve","Vector","origin","init","_options$position","_options$reverse","_options$scale","_options$width","options","actualOptions","particles","move","reverse","url","_svg$getAttribute","_svg$getAttribute2","response","fetch","data","text","doc","DOMParser","parseFromString","firstIndex","svg","getElementsByTagName","svgPaths","i","item","push","getTotalLength","parseFloat","getAttribute","document","createElementNS","setAttribute","reset","update"],"sourceRoot":""}